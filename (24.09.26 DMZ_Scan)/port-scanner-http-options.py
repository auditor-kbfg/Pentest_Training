import socket
import ssl
import requests
from concurrent.futures import ThreadPoolExecutor
import sys
from datetime import datetime
import time

def scan_port(ip, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        return port if result == 0 else None

def get_server_info(ip, port, use_https):
    try:
        protocol = "https" if use_https else "http"
        url = f"{protocol}://{ip}:{port}"
        response = requests.get(url, timeout=2, verify=False)
        server = response.headers.get('Server', 'Unknown')
        length = len(response.content)
        return server, length
    except requests.RequestException:
        return None, None

def get_allowed_methods(ip, port, use_https, path):
    try:
        protocol = "https" if use_https else "http"
        url = f"{protocol}://{ip}:{port}{path}"
        response = requests.options(url, timeout=2, verify=False)
        return response.headers.get('Allow', 'No Allow header')
    except requests.RequestException:
        return None

def send_put_request(ip, port, use_https, max_retries=3):
    protocol = "https" if use_https else "http"
    url = f"{protocol}://{ip}:{port}/"
    for attempt in range(max_retries):
        try:
            response = requests.put(url, timeout=2, verify=False)
            if response.status_code == 503:
                print(f"Received 503 for {url}. Retrying in 5 seconds...")
                time.sleep(5)
                continue
            return response.status_code, len(response.content)
        except requests.RequestException:
            pass
    return None, None

def save_put_results(ip, port, protocol, status_code, length):
    with open('put_results.txt', 'a') as file:
        file.write(f"{ip}:{port} ({protocol}) - Status: {status_code}, Length: {length}\n")
    print(f"PUT request results for {ip}:{port} ({protocol}) saved to put_results.txt")

def scan_ports(ip):
    open_ports = []
    total_ports = 65535
    print(f"Scanning ports for {ip}...")
    with ThreadPoolExecutor(max_workers=1000) as executor:
        futures = [executor.submit(scan_port, ip, port) for port in range(1, total_ports + 1)]
        for i, future in enumerate(futures):
            port = future.result()
            if port:
                open_ports.append(port)
                print(f"Open port found: {port}")
            if (i + 1) % 10000 == 0:
                print(f"Progress: {i + 1}/{total_ports} ports scanned")
    return open_ports

def read_ips_from_file(filename):
    with open(filename, 'r') as file:
        return [line.strip() for line in file if line.strip()]

def save_ports(ip, ports):
    with open('port.txt', 'a') as file:
        file.write(f"{ip}: {','.join(map(str, ports))}\n")
    print(f"Open ports for {ip} saved to port.txt")

def save_server_info(ip, port, server, length, protocol):
    with open('server.txt', 'a') as file:
        file.write(f"{ip}:{port} ({protocol}) - Server: {server}, Length: {length}\n")
    print(f"Server info for {ip}:{port} ({protocol}) saved to server.txt")

def save_methods(ip, port, methods, protocol, path):
    with open('methods.txt', 'a') as file:
        file.write(f"{ip}:{port} ({protocol}) - Path: {path} - Allowed Methods: {methods}\n")
    print(f"Allowed methods for {ip}:{port} ({protocol}) {path} saved to methods.txt")

def main():
    ips = read_ips_from_file('ip.txt')
    print(f"Loaded {len(ips)} IP addresses from ip.txt")
    
    for ip in ips:
        print(f"\nStarting scan for {ip}...")
        open_ports = scan_ports(ip)
        print(f"Scan completed for {ip}. Found {len(open_ports)} open ports.")
        save_ports(ip, open_ports)
        
        for port in open_ports:
            for use_https in [False, True]:
                protocol = "https" if use_https else "http"
                print(f"Checking {protocol.upper()} on {ip}:{port}")
                server, length = get_server_info(ip, port, use_https)
                if server and length:
                    save_server_info(ip, port, server, length, protocol)
                    for path in ['/', '/a']:
                        print(f"Sending OPTIONS request to {ip}:{port}{path} ({protocol})")
                        methods = get_allowed_methods(ip, port, use_https, path)
                        if methods:
                            save_methods(ip, port, methods, protocol, path)
                        else:
                            print(f"No valid response for OPTIONS request on {ip}:{port}{path} ({protocol})")
                    
                    # 새로 추가된 PUT 요청 부분
                    print(f"Sending PUT request to {ip}:{port} ({protocol})")
                    status_code, content_length = send_put_request(ip, port, use_https)
                    if status_code is not None:
                        save_put_results(ip, port, protocol, status_code, content_length)
                    else:
                        print(f"No valid response for PUT request on {ip}:{port} ({protocol})")
                else:
                    print(f"No valid response from {ip}:{port} ({protocol})")
        
        print(f"Scan and analysis completed for {ip}")

if __name__ == "__main__":
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
    print("Starting port scanning and HTTP/HTTPS analysis script...")
    main()
    print("Script execution completed.")
